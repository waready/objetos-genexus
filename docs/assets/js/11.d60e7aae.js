(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{432:function(e,a,t){"use strict";t.r(a);var r=t(65),o=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"data-provider"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#data-provider"}},[e._v("#")]),e._v(" Data Provider")]),e._v(" "),t("p",[e._v("El propósito de los Data Providers es obtener información jerárquica para que quien la necesita pueda luego hacer algo con ella. Recordemos que en los Data Providers el foco está ubicado en el lenguaje de salida: se indica en una estructura jerárquica cómo se compone ese output. Por eso se habla de un proceso de transformación de los datos de entrada en esa salida estructurada. Datos que pueden ser de la base de datos o no.")]),e._v(" "),t("p",[e._v("La manera de representar estructuras jerárquicas en GeneXus es con el objeto "),t("a",{attrs:{href:"http://library.gxtechnical.com/gxdlsp/dist/GeneXus/DevEnv/Docum/ReleaseNotes/8.0/StructureDatatype.htm#:~:text=El%20objeto%20GeneXus%20Structured%20Data,facilita%20y%20potencia%20la%20programaci%C3%B3n.",target:"_blank",rel:"noopener noreferrer"}},[e._v("SDT"),t("OutboundLink")],1),e._v(", junto con la posibilidad de definir colecciones. Por supuesto, un Business Component puede pensarse estructuralmente como un "),t("a",{attrs:{href:"http://library.gxtechnical.com/gxdlsp/dist/GeneXus/DevEnv/Docum/ReleaseNotes/8.0/StructureDatatype.htm#:~:text=El%20objeto%20GeneXus%20Structured%20Data,facilita%20y%20potencia%20la%20programaci%C3%B3n.",target:"_blank",rel:"noopener noreferrer"}},[e._v("SDT"),t("OutboundLink")],1),e._v(". Es por ello que en la propiedad Output del Data Provider podremos especificar tanto un "),t("a",{attrs:{href:"http://library.gxtechnical.com/gxdlsp/dist/GeneXus/DevEnv/Docum/ReleaseNotes/8.0/StructureDatatype.htm#:~:text=El%20objeto%20GeneXus%20Structured%20Data,facilita%20y%20potencia%20la%20programaci%C3%B3n.",target:"_blank",rel:"noopener noreferrer"}},[e._v("SDT"),t("OutboundLink")],1),e._v(" como un Business Component. Y además tenemos la propiedad Collection para poder indicar que la salida será una colección de ese tipo de datos indicado, o no, o será un único ítem.")]),e._v(" "),t("h2",{attrs:{id:"funcionalidad-gx"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#funcionalidad-gx"}},[e._v("#")]),e._v(" Funcionalidad Gx")]),e._v(" "),t("p",[e._v("De modo que un Data Provider siempre devolverá a quien lo llame una jerarquía, ya sea un "),t("a",{attrs:{href:"http://library.gxtechnical.com/gxdlsp/dist/GeneXus/DevEnv/Docum/ReleaseNotes/8.0/StructureDatatype.htm#:~:text=El%20objeto%20GeneXus%20Structured%20Data,facilita%20y%20potencia%20la%20programaci%C3%B3n.",target:"_blank",rel:"noopener noreferrer"}},[e._v("SDT"),t("OutboundLink")],1),e._v(", una colección de "),t("a",{attrs:{href:"http://library.gxtechnical.com/gxdlsp/dist/GeneXus/DevEnv/Docum/ReleaseNotes/8.0/StructureDatatype.htm#:~:text=El%20objeto%20GeneXus%20Structured%20Data,facilita%20y%20potencia%20la%20programaci%C3%B3n.",target:"_blank",rel:"noopener noreferrer"}},[e._v("SDT"),t("OutboundLink")],1),e._v(", un Business Component, o una colección de Business Components.")]),e._v(" "),t("img",{attrs:{src:e.$withBase("/img/01.png")}}),e._v(" "),t("img",{attrs:{src:e.$withBase("/img/02.png")}}),e._v(" "),t("p",[e._v("Aquí vemos cómo GeneXus ofrece diferentes métodos de conversión entre SDTs y algunos de esos otros formatos. Si en el futuro aparece un nuevo formato de representación de información estructurada, el Data Provider continuará invariable. GeneXus implementará el método de transformación a ese formato, y solo habrá que utilizarlo. Podemos tanto convertir de SDT a otro formato, como a la inversa: de ese otro formato a SDT. Esto ya no tiene que ver con el Data Provider en si, sino con los tipos de datos estructurados. El obtener la colección de países podría haberse logrado con un procedimiento en lugar de un Data Provider, y la parte de la conversión sería idéntica.")]),e._v(" "),t("h2",{attrs:{id:"estructura-y-ejemplos"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#estructura-y-ejemplos"}},[e._v("#")]),e._v(" Estructura y Ejemplos")]),e._v(" "),t("p",[e._v("Veamos este ejemplo. Supongamos que, en el contexto de una aplicación para una agencia de viajes, necesitamos mostrar en pantalla un ranking de países, ordenados de mayor a menor por cantidad de atracciones turísticas para visitar que cada uno tiene. En nuestra realidad tenemos las transacciones Country y Attraction con los siguientes atributos. Una forma sencilla de conseguirlo es declarar un Data Provider que devuelva una colección de países donde para cada uno se agregue, además de su nombre e identificador, la cantidad de atracciones que posee. Y luego procesar esa colección en orden inverso por esa cantidad. Como dijimos, el lenguaje del Data Provider coloca el foco en la salida, se calculan los elementos desde el punto de vista de la jerarquía que resultará.")]),e._v(" "),t("img",{attrs:{src:e.$withBase("/img/03.png")}}),e._v("\nPara representar este ejemplo, creamos la siguiente estructura de datos\nque será la que posteriormente devuelva el Data Provider. Y luego\ndebemos cargar este objeto SDT dentro del Source del Data Provider\n"),t("div",{staticClass:"language-GeneXus extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    Countries\n    {\n        CountriesItem\n        {\n            Id = /*Id Value*/\n            Name = /*Name Value*/\n            AttractionsQuantity = /*Attractions Quantity value*/\n        }\n    }\n")])])]),t("hr"),e._v(" "),t("div",{staticClass:"language-GeneXus extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    Countries\n    {\n        CountriesItem\n        {\n            Id = CountryId\n            Name = CountryName\n            AttractionsQuantity = count(AttractionName)\n        }\n    }\n")])])]),t("p",[e._v("Al arrastrar dentro de él el SDT que será el output del Data Provider, ya nos\npresenta la estructura que tenemos que cargar. Vemos claramente cómo\nsu lenguaje está orientado hacia la declaración de salida")]),e._v(" "),t("img",{attrs:{src:e.$withBase("/img/04.png")}}),e._v(" "),t("h2",{attrs:{id:"aportes-bantotal-y-concluciones"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aportes-bantotal-y-concluciones"}},[e._v("#")]),e._v(" Aportes Bantotal y Concluciones")]),e._v(" "),t("p",[e._v("Basandonos en datos "),t("a",{attrs:{href:"http://library.gxtechnical.com/gxdlsp/dist/GeneXus/DevEnv/Docum/ReleaseNotes/8.0/StructureDatatype.htm#:~:text=El%20objeto%20GeneXus%20Structured%20Data,facilita%20y%20potencia%20la%20programaci%C3%B3n.",target:"_blank",rel:"noopener noreferrer"}},[e._v("SDT"),t("OutboundLink")],1),e._v(", tendriamos una Programacion mas orientada a Objetos pudiendo remplazar otro tipo de objetos que se usan frecuentemente como "),t("code",[e._v("array o vectores")]),e._v(" a los cuales haciamos un recorrido para sacar los datos pre obtendios con un filtro los caules pueden ser remplazados por una funcion como "),t("code",[e._v(".sort()")]),e._v(", incluso podriamos usar otros tipos de parametros o funciones que nos proporciona los "),t("code",[e._v("Data Provider")]),e._v(" como los siguientes:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("DataProvider.sort()")])]),e._v(" "),t("li",[t("code",[e._v("DataProvider.count()")])]),e._v(" "),t("li",[t("code",[e._v("DataProvider.Add(&Parametro)")])]),e._v(" "),t("li",[t("code",[e._v("DataProvider.remove(&index)")])]),e._v(" "),t("li",[t("code",[e._v("DataProvider.clear()")])])]),e._v(" "),t("p",[e._v("Para tener mas conocimiento de esto pueden acceder a "),t("a",{attrs:{href:"https://wiki.genexus.com/commwiki/servlet/wiki?6352,Collection%20variables",target:"_blank",rel:"noopener noreferrer"}},[e._v("Parametros"),t("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);a.default=o.exports}}]);